class Witchkitchen:
    """
    this is the class for all potential moves for the codingame autumn challenge.
    """
    
    
    def __init__(self):
        """
        this will initialise the class lists
        """
        
        self.turnbrewlist=[]
        self.turnspelllist=[]
        self.turninventory=[]
        self.cpturn_inventory=[]
        
        self.spelllist=[]
        self.spellinventory=[]
        
    def add_brew(self,action_id,d_0,d_1,d_2,d_3,price,urgence_b,ugency_t):
        """
        this will add any potion recipies to the class at the start of each turn
        """
        self.turnbrewlist.append((action_id,d_0,d_1,d_2,d_3,price,urgence_b,ugency_t,castable)
      
    
    def add_cast(self,action_id,d_0,d_1,d_2,d_3,castable,repeatable):
        """
        this will add any spells to the class at the start of each turn
        """
    
        self.turnspelllist.append((action_id,d_0,d_1,d_2,d_3,castable,repeatable))
                                 
                                 
    def add_learn(self,action_id,d_0,d_1,d_2,d_3,tome_index,tax_count):
        """
        this will add any learnable spells to the class at the start of each turn
        """
        pass
        
    def turn_input(self,action_id, action_type,d_0,d_1,d_2,d_3,price,tome_index,tax_count ,castable,repeatable):
        """
        sorts the turns data into the approtriate list
        """
        
        if action_type=="BREW":
            add_brew(action_id,d_0,d_1,d_2,d_3,price,tome_index,tax_count ,castable)
        elif action_type=="CAST":
            add_cast(action_id,d_0,d_1,d_2,d_3,castable,repeatable)
        elif action_type=="LEARN":
            add_learn(action_id,d_0,d_1,d_2,d_3,tome_index,tax_count)
            
            
            
        
    def intentory_input(self,inv_0, inv_1, inv_2, inv_3, score, player):
        """
        Creates inventories for human player and CPU player
        """
        if player==0:
            self.turninventory=(inv_0, inv_1, inv_2, inv_3, score)
        elif player==1:
            self.cpturn_inventory=(inv_0, inv_1, inv_2, inv_3, score)
    
        
        
            
    def player_check_potion(self,potion):
        """
        will work out if sufficient iteams in inventory for the potion to be made
        """
        
        if self.inventory[0]>=potion[0] and self.inventory[1]>=potion[1] and self.inventory[2]>=potion[2] and self.inventory[3]>=potion[3]:
            ### returns true if player can do the potion
            return True
        else:
            return False
    
    def comp_check_potion(self,potion):
        """
        will work out if sufficient iteams in inventory for the potion to be made
        """
        
        if self.cp_inventory[0]>=potion[0] and self.cp_inventory[1]>=potion[1] and self.cp_inventory[2]>=potion[2] and self.cp_inventory[3]>=potion[3]:
            ### returns true if computer can do the potion.
            return True
        else:
            return False
        
                                 
    def spellinventory_update(self, potion):
       """
       update the self.inventory figures
       """ 
        new_inventory=(potion[0]+self.inventory[0],potion[1]+self.inventory[1],potion[2]+self.inventory[2],potion[3]+self.inventory[3],potion[4]+self.inventory[4])
        self.inventory=new_inventory
        
                                 
    def brewinventory_update(self, brew):
       """
       update the self.inventory figures
       """ 
        new_inventory=(brew[0]+self.inventory[0],brew[1]+self.inventory[1],brew[2]+self.inventory[2],brew[3]+self.inventory[3],brew[4]+self.inventory[4])
        self.inventory=new_inventory  
                                 
              
                                 
    def spell_remove(self,potion):
        """
        method to update spelllist with castable to 0 when used
        """
                                 
        if potion[-1]==0:
            p_index=self.spelllist.index(potion)
            self.spelllist[p_index]=(self.spelllist[p_index][:-2],0,0)
                                 
            
                                 
    def potion_distance(self, player, potion):
        """
        calculates the number of basic steps required to afford the potion, using simple 1-1 conversion 
        as a analog to distance from potion
        """ 
        if player==0:            
            in_play_invent=self.inventory[:-1]
            
        if player==1:
            in_play_invent=self.cp_inventory[:-1]
            
        zpotion=self.brew[:-3]
        c=0
                                 
        for i,j in enumerate(zpotion[::-1]):
            if i<3:
                i=i+1
                while j>in_play_invent[-i]:
                    in_play_invent[-i]+=1
                    in_play_invent[-(i+1)]-=1
                    c+=1

        while zpotion[0]>in_play_invent[0]:
            in_play_invent[0]+=2
            c+=1
        return c
    
    def Stimulate_go (self):
        """
        code to simulate all potential combinations of 3 potions
        """
                                 
        for index,potion in self.turnspelllist:
            self.spelllist=self.turnspelllist   "create class assets of the saved actaul turn properties"
            self.inventory=self.turninventory 
            if self.player_check_potion(potion)==True:
                self.spellinventory_update(potion)
                                 
                self.spell_remove(potion)
                
                if self.player_check_potion==True:
                                 
                                 
                inventory_copy=self.inventory
                spelllist_copy=self.spelllist
                ###so I need to check for potions and then make a list including brew potion and cast spells- maybe new method
                              ##   to brew
                
            
        
            